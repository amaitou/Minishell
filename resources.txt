https://cs61.seas.harvard.edu/cs61wiki/images/3/3f/Fork-exec.pdf :=> Making Processes {

	Two models of process creation : {

		Copying an existing process (UNIX fork/exec).

		Single system call that creates a new process (Windows).
	}

	fork : {

		System call that creates an identical (almost) copy of the calling process.

		If fork call was successful :{
			fork returns the pid of the CHILD to the PARENT.

			fork returns 0 to the CHILD.
		}

		If fork fails : {
			No child process is created.

			-1 is returned to the PARENT and errno is set.
		}
	}

	fork sometimes sucks ass : {

		fork creates an identical process which might not be very handy.

		The exec family on the otherhand replaces the current process image with a new one.

		exec is the original/traditional API.

		execve is a modern implementation (more efficient).

		If execvp ever returns (-1), it means it failed and errno is set.

		If execvp was successful then it will never return because it will be running
		as a new process.

		execvp takes the following arguments : {
			file : Name of the executable.

			args : A NULL-terminated vector,the first entry of which is by convention the
			file name associated with the file being executed.
		}
	}

	Coordinating with a CHILD process : {

		Sometimes it's useful for a PARENT to wait until a specific, all or any CHILD exits.
			// pid_t wait (int *stat_loc);
			// pid_t waitpid (pid_t pid, int *stat_loc, int options);

		wait : {
			suspends execution of the PARENT until some CHILD of the PARENT terminates or the
			PARENT recieves a signal.
				// return value is the pid of the terminating process.
				// stat_loc is filled in with a status indicating how/why the CHILD terminated.
		}

		waitpid : {
			suspends until a particular (or all) CHILD terminates.
		}
	}

	Communicating with CHILD processes : {

		pipes 101 : {
			When you type : [bilal@1337] $ foo | bar, the stdout stream of foo is connected
			to the stdin stream of bar.

			stdin, stdout and stderr are opened on behalf of every process.
				// By convention, stdin comes from the console.
				// by convention, stdout goes to the display.

			Allowing two proceses to interact as shown above requires foo's stdout and
			bar's stdin to be connected.
		}
	}

	The pipe system call : {

		pipe (int filedes[2]) creates a pair of file descriptors and places them in
		the array referenced by filedes.
			// filedes[0] is for reading.
			// filedes[1] is for wrinting.

		file descriptors are shared between CHILDren and the PARENT.

		By combining fork, exec and pipe, PARENTs can communicate with CHILDren and/or
		set up pipelines between CHILDren.
	}

	The dup2 system call : {

		dup2 (int filedes, int filedes2);

		duplicates the first file descriptor (filedes) into the second file descriptor
		(filedes2).

		After the call, both file descriptors refer to the same object, so reading
		from/writing to one descriptor changes the file position in both descriptors.

		If filedes2 already refers to an open object, that object is closed.
	}

	brief : {

		On most UNIX-like systems today, we use fork/exec to create new processes.

		wait and waitpid allow PARENTs and CHILDren to synchronize.

		the dup2 and pipe calls provide for communication between parents and children.
	}

	About the above : { 
		Read in depth about files and file descriptors.
		Read in depth about processes.
		Read in depth about pipes.
		Read in depth about system calls and their general proprieties.
		Read in depth about streams.
		Read in depth about file pointers?
	}
};
